---
layout: post
title: "haxkcd: solving the 2016 hackmit puzzle"
date: "2016-07-18"
---

wow more puzzles

I thought that this year's puzzle wasn't as good as last year's,
but I still enjoyed it. Sadly don't think I'll be able to go
to HackMIT this year though.

Here's how I solved them:

# step 1: find the puzzle
Inspecting the source for hackmit.org gives us a suspicious error message for the SVG logo.
![start]({{ site.url }}/blog-images/haxkcd/start.png)
Technical error? I THINK NOT. Further inspection of the SVG reveals
that there are hidden letters that are draggable and trigger `deleteLetters()` when they're all into place.

This reveals haxkcd.com
![haxkcd]({{ site.url }}/blog-images/haxkcd/haxkcd.png)

and after a github login, we're in!
![haxkcd]({{ site.url }}/blog-images/haxkcd/unihaxkcd1.png)

# puzzle 1: time
![time]({{ site.url }}/blog-images/haxkcd/time.png)

This one was easier than it looked. Solving this puzzle
requires that you know or have seen [xkcd 426: Geohashing](https://xkcd.com/426/).

Run the location and date, ignoring time, through the [sample implementation](xkcd.com/geohashing) and you get your solution.
![time]({{ site.url }}/blog-images/haxkcd/time2.png)

In this case for 9/15/2015 Cambride, MA, `42.197022 -71.597812`

# puzzle 2: bobby tables
Puzzle 2 links you to a very shoddy-looking website for "Xavier Kalos Child Development Elementary". There are hints of [bobby tables](https://xkcd.com/327/), but poking around a bit trying to find a vulnerability is fruitless. However if you try to register with a blank username, you get this:

```
ValidationError: Path `username` is required.
    at MongooseError.ValidationError (/home/ubuntu/hackmit-puzzle-2016/bobby/node_modules/mongoose/lib/error/validation.js:22:11)
    at model.Document.invalidate (/home/ubuntu/hackmit-puzzle-2016/bobby/node_modules/mongoose/lib/document.js:1416:32)
    at EmbeddedDocument.invalidate (/home/ubuntu/hackmit-puzzle-2016/bobby/node_modules/mongoose/lib/types/embedded.js:191:19)
    at /home/ubuntu/hackmit-puzzle-2016/bobby/node_modules/mongoose/lib/document.js:1292:17
    at validate (/home/ubuntu/hackmit-puzzle-2016/bobby/node_modules/mongoose/lib/schematype.js:701:7)
    at /home/ubuntu/hackmit-puzzle-2016/bobby/node_modules/mongoose/lib/schematype.js:738:9
    at Array.forEach (native)
    at SchemaString.SchemaType.doValidate (/home/ubuntu/hackmit-puzzle-2016/bobby/node_modules/mongoose/lib/schematype.js:706:19)
    at /home/ubuntu/hackmit-puzzle-2016/bobby/node_modules/mongoose/lib/document.js:1290:9
    at process._tickCallback (node.js:415:13)
```

SQL injection doesn't work because it's running MongoDB! Quick googling yields `{"$gt": ""}` for both the username and password as a possible vulnerablility for naive implementations.

This login gets you into the admin panel, which shows the username and hashed password for all the students that you've attempted to make. After some long experimentation, the solution was to make a user with a long string of spaces for the password, and then run it through a hex to ASCII converter.

![xkcde]({{ site.url }}/blog-images/haxkcd/xkcde-solution.png)
My answer was `divide magazine`

# puzzle 3: velociraptor
This was one of those puzzles where it was easier to just write a script to solve it than it was to do it manually. You use a handmade programming language to make your character avoid the velociraptors and into the goal square. The first three are simple to do manually, but the last one was just a pain.
![velociraptor]({{ site.url }}/blog-images/haxkcd/velociraptor.png)

```python
frames = <toolong>
start = (8,6)
goal = (14,10)
time = 0
def valid(x,y,t):
    for x1,y1 in [(x, y), (x+1, y), (x-1, y), (x, y+1), (x, y - 1)]:
        if 0 <= x1 <= 14 and 0 <= y1 <= 14 and frames[t][x1][y1] != 1:
            yield (x1,y1)


def search(start,goal,t,path=[]):
    if start == goal:
        print('=================== GOAL FOUND =================')
        print(path + [goal])
        return path + [goal]
    if (t == 20):
        print('Not found')
        return
    for x,y in valid(start[0], start[1], t):
        r = search((x,y), goal, t+1, path + [start])
        if r:
            return r

def text(path):
    p = []
    s = path[0]
    for n in path[1:]:
        diffx = n[0] - s[0]
        diffy = n[1] - s[1]
        if (diffx == 0 and diffy == 1):
            t = "r"
        elif (diffx == 0 and diffy == -1):
            t = "l"
        elif (diffx == -1 and diffy == 0):
            t = "u"
        else: # (diffx == 1 and diffy == 0):
            t = "d"
        p.append(t)
        s = n
    print("solution: ")
    print('u { moveUp }\nl { moveLeft }\nr { moveRight }\nd { moveDown }')
    print('\n'.join(p))

text(search(start, goal, 0))
```

script output:

```
=================== GOAL FOUND =================
[(8, 6), (8, 7), (9, 7), (9, 6), (9, 5), (8, 5), (7, 5), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9), (6, 10), (7, 10), (8, 10), (9, 10), (10, 10), (11, 10), (12, 10), (13, 10), (14, 10)]
solution:
u { moveUp }
l { moveLeft }
r { moveRight }
d { moveDown }
r
d
l
l
u
u
u
r
r
r
r
r
d
d
d
d
d
d
d
d
```

# puzzle 4: sportsball
![sports]({{ site.url }}/blog-images/haxkcd/sports.png)
This puzzle was incredibly frustrating since I had a working script after a couple of hours,
but I wasn't masking the numbers properly so all the numbers were wrong.

Reading the page for a bit, it seems that it's asking you to predict the next number that
the random number generator will produce. Seems impossible, but incredibly possible if
that random number generator was not truly random, but was pseudo-random. And especially if
that generator was based on xorshift128+. Inspecting the network shows that the generator is
indeed xorshift128+, keeping only the last 52 bits (16-digit integers).

My version of the script took forever to run, because I left out the implication statement :disappointed:

```python
## modified from
## https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f#.i18fnqv2b

import sys
import math
import struct
import random
from z3 import *

# xor_shift_128_plus algorithm
def xs128p(state0, state1):
    s1 = state0 & 0xFFFFFFFFFFFFFFFF
    s0 = state1 & 0xFFFFFFFFFFFFFFFF
    s1 ^= (s1 << 23) & 0xFFFFFFFFFFFFFFFF
    s1 ^= (s1 >> 17) & 0xFFFFFFFFFFFFFFFF
    s1 ^= s0 & 0xFFFFFFFFFFFFFFFF
    s1 ^= (s0 >> 26) & 0xFFFFFFFFFFFFFFFF
    state0 = state1 & 0xFFFFFFFFFFFFFFFF
    state1 = s1 & 0xFFFFFFFFFFFFFFFF
    generated = (state0 + state1) & 0xFFFFFFFFFFFFFFFF

    return state0, state1, generated

# Symbolic execution of xs128p
def sym_xs128p(slvr, sym_state0, sym_state1, generated):
    s1 = sym_state0
    s0 = sym_state1
    s1 ^= (s1 << 23)
    s1 ^= LShR(s1, 17)
    s1 ^= s0
    s1 ^= LShR(s0, 26)
    sym_state0 = sym_state1
    sym_state1 = s1
    calc = (sym_state0 + sym_state1)
    condition = Bool('c%d' % int(generated * random.random()))
    impl = Implies(condition, (calc & 0xFFFFFFFFFFFFF) == int(generated))

    slvr.add(impl)
    return sym_state0, sym_state1, [condition]


def main():
    generated = <last refresh of /xorshift128plus>

    # setup symbolic state for xorshift128+
    ostate0, ostate1 = BitVecs('ostate0 ostate1', 64)
    sym_state0 = ostate0
    sym_state1 = ostate1
    slvr = Solver()
    conditions = []

    # run symbolic xorshift128+ algorithm for three iterations
    # using the recovered numbers as constraints
    for ea in range(3):
        sym_state0, sym_state1, ret_conditions = sym_xs128p(slvr, sym_state0, sym_state1, generated[ea])
        conditions += ret_conditions

    if slvr.check(conditions) == sat:
        # get a solved state
        m = slvr.model()
        state0 = m[ostate0].as_long()
        state1 = m[ostate1].as_long()
        print(state0, state1)
        s0, s1 = state0, state1
        for dd in range(201):
            s0, s1, gen = xs128p(s0, s1)
            print(s0, s1, gen)
            print(gen & 0xFFFFFFFFFFFFF)
    else:
        print('UNSAT')

main()
```
